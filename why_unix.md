# Почему Unix?

Можно сколько угодно спорить о достоинствах и недостатках различных систем, привлекая аргументы из самых разных предметных областей — технических, экономических, философских, каких угодно. Здесь я попытаюсь ответить на вопрос существенно более узкий: почему именно системы семейства Unix (в том числе Linux и FreeBSD) необходимы при обучении программированию, если нужно при этом достичь хоть сколько-нибудь приемлемого результата. Я выделю здесь четыре основные причины.


### Причина первая — математическая

Итак, любая компьютерная программа есть ни что иное как запись некоторого алгоритма на избранном языке программирования. Что такое алгоритм — никто в действительности не знает и знать, что интересно, не может (иначе пришлось бы выбросить на свалку всю теорию вычислимости заодно с теорией алгоритмов, забыть тезис Чёрча-Тьюринга и вообще отказаться от теоретической составляющей computer science). Тем не менее, принято считать, что всякий алгоритм есть преобразование из множества слов (цепочек символов) над некоторым алфавитом в само это же множество. Конечно, не всякое такое преобразование является алгоритмом, ведь преобразований таких, как несложно показать, континуум, тогда как алгоритмов — множество не более чем счётное; но всякий алгоритм — именно такое преобразование, и ничто иное. Иначе говоря, алгоритм — это такая штука, которая берёт некое входное слово (если угодно, прочитывает его), что-то там такое конструктивное делает и выдаёт другое слово; неопределённость понятия здесь заключена в слове «конструктивное», которое тоже, разумеется, невозможно определить.

Многие программы в системах семейства Unix работают именно так: читают данные из стандартного потока ввода и записывают их в стандарный поток вывода. Такие программы имеют даже своё название — фильтры. Благодаря развитым средствам командной строки такие программы-фильтры можно комбинировать «на лету», решая самые разнообразные задачи, сводящиеся к преобразованию текста. Поскольку текстовое представление практически универсально, алгебра консольных программ оказывается средством неожиданно мощным. Но при обучении главное не это. Каждая новая консольная программа, сколь бы простой она ни была, становится частью этой системы, делая её, систему, ещё немного мощнее, а диапазон решаемых задач — ещё немного шире.

Всё это даёт возможность начинающему программисту написать настоящую программу, а не игрушечный этюд. Почему это столь важно, нам поможет понять


### Причина вторая — психологическая

Программирование, в конечном счёте, не более чем ремесло, а ремесло выучить невозможно, ему можно только научиться, пусть даже самостоятельно. Прежде чем новичок превратится в программиста, ему необходимо сделать ряд очень важных шагов.

**Первый шаг** — это переход от задач из учебника к задачам, поставленным самостоятельно, при этом не вымученным, не делаемым «потому что надо», а таким, которые делаются, потому что данному конкретному субъекту показалось интересно решить именно такую задачу, подчинив себе компьютер.

**Второй шаг** — переход от этюдов к реальному решению реально вставшей перед учеником проблемы, пусть сколь угодно простой, но настоящей. Это может быть какой-нибудь календарь или записная книжка, напоминалка о днях рождения друзей, какой-нибудь простой преобразователь текстов (а хоть бы и для удаления лишних пробелов), всё, что угодно. Для автора этих строк в своё время такой программой стала «ломалка» для игры f19, которая подправляла нужный байтик в файле списка пилотов, делая погибшего пилота обратно живым. Найти нужный байтик оказалось существенно сложнее, нежели потом написать программу на Паскале, которая в нужные позиции нужного файла тупо записывает нули, и тем не менее именно эта примитивная, на один экран программка позволила прыгнуть, как говорят, на следующий уровень, о чём сам ваш покорный слуга догадался лишь лет через десять.

**Третий шаг** будущий программист замечает, когда этот шаг давно уже сделан. Новое качество в этот раз состоит в том, что у какой-то, пусть даже очень и очень примитивной программы, написанной вами, появляется сторонний пользователь. Конечно, ни о каких деньгах тут речи не идёт: речь идёт о том, что вам удалось написать не просто полезную программу, а такую, полезность которой оценил (реально, а не на словах) кто-то кроме вас самих. Иначе говоря, нашелся кто-то, кто согласен тратить время, пользуясь вашей программой, потому что получаемые результаты оказываются для него ценнее потраченного времени. Во многих случаях такой программой оказывается какая-нибудь простенькая игрушка, реже — что-то более серьёзное, какой-нибудь несложный каталогизатор или ещё что подобное. Факт тот, что осознать здесь свой переход на новый уровень вы можете не тогда, когда собственно делаете его: программу-то вы, быть может, и напишете, но заранее знать, что кто-то станет её использовать, вы никак не можете. И лишь когда вы вдруг обнаруживаете, что кто-то действительно начал пользоваться вашей поделкой, причём не потому, что вы его слёзно умоляли, а сам, добровольно, — вот в этот момент можете себя поздравить от всей души: **вы стали программистом**.

Конечно, будет ещё и четвёртый рубеж — получение денег за работу по написанию программ. Состоявшимся профессионалом в большинстве случаев можно считать себя лишь после этого. Однако разница между профессионалом и любителем отнюдь не столь значительна, как между программистом и не-программистом. В конце концов, истории известны примеры, когда к моменту первого монетарного эффекта от своей программистской деятельности человек имел уже такую высокую квалификацию, что усомниться в его профессионализме никто бы не рискнул; взять хоть Линуса Торвальдса.

Так вот, к чему я это всё говорю. **Если, обучая человека программировать, мы пользуемся для этого системами семейства Windows, мы тем самым лишаем его возможности сделать все три вышеперечисленных шага.** Настоящую программу под Windows, под каковой можно понимать только, и исключительно, оконные приложения, можно написать, только уже будучи программистом; текстовые программки, которые большинство горе-педагогов даже не может объяснить, как правильно запускать (ага, привет readln'у в конце каждой программы), настоящими не выглядят ни анфас, ни в профиль, а потому у такой программы никогда не появится стороннего пользователя, да и сам автор пользоваться этим непонятно-чем не станет. Больше того, если результат столь убог и нет никаких шансов сделать его сколько-нибудь похожим на нечто настоящее, вряд ли нашего обучаемого заинтересует перспектива потратить несколько часов из оставшейся ему жизни, чтобы сделать вот такое вот никуда не годное решение пусть даже очень интересной задачи.

Именно поэтому обучаемому жизненно важно не просто программировать под Unix, ему необходимо жить под Unix'ом, то есть именно Unix (будь то Linux или любая другая unix-система) использовать в повседневной работе, для прогулок по интернету, общения по электронной почте и через instant messaging, для работы над текстами, для просмотра фильмов и фотографий, вообще для всего, для чего обычно используют компьютеры.


### Причина третья — эргономическая

К каким бы ухищрениям ни прибегали создатели графических пользовательских интерфейсов, по эффективности использования и тому, что называется английским словом usability, им никогда не переплюнуть и не обогнать старую добрую командную строку. Не соглашаются с этим утверждением лишь те, кто в командной строке работать не умеет, а не умеют обычно те, кто никогда этого делать всерьёз не пробовал.

Не представляя своей жизни без GUI, вы никогда (sic!) не поймёте, как на самом деле должна выглядеть работа с компьютером. Большинство современных программ с точки зрения usability представляют собой уродливых монстров, на борьбу с изъянами которых у пользователей уходит девять десятых всех сил, при этом пользователи ухитряются этого положения в упор не замечать, потому что просто не знают, что может быть как-то иначе. Именно поэтому необходимо освоить командную строку (пусть даже не строя планов по прекращению использования GUI: это произойдёт само собой), и делать это нужно как можно раньше, пока мозг не потерял способность к быстрому обучению и мгновенной адаптации к непривычным условиям: после 25 лет ничего принципиально нового человеку уже в большинстве случаев не осилить.

Ну а действительно полноценные средства командной строки за пределами семейства Unix, извините, не водятся. Так уж получилось.


### Причина четвёртая — педагогическая

Если среди учеников, пытающихся освоить программирование в нечеловеческих виндовых условиях, всё же окажется будущий программист, страшные псевдо- и недопрограммы, которые его заставляют писать (чаще всего, в какой-нибудь безнадёжно мёртвой среде вроде турбо-паскаля), очень быстро перестанут такого субъекта удовлетворять, и ему захочется чего-то настоящего. Учитель вряд ли станет объяснять продвинутому ученику, как писать оконные программы под Windows (большинство учителей не умеют этого сами), но будущего программиста такие мелочи никогда не остановят. Взяв в руки первую попавшуюся книжку, он освоит рисование окошек самостоятельно.

В некоторых (увы, довольно редких) случаях даже это не сможет его испортить, и через несколько лет такой ученик, на самом деле буквально родившийся программистом, станет грамотным и матёрым спецом, за которого передерутся работодатели. Люди такого класса, такие, кого с правильного пути не своротит никакой учитель и никакой министр образования, реально существуют; больше того, на этих уникумах держится вся современная индустрия. Проблема в том, что таких людей очень, очень, **очень** мало.

Гораздо чаще наблюдается совершенно иная картина: начав с рисования окошек, новичок необратимо травмирует собственное мышление, поставив мир с ног на голову: обдумывать программу он начинает не с предметной области, а с элементов графического интерфейса, они же (точнее, обработчики их событий) становятся своеобразным скелетом любой его программы, на которые навешивается "мясо" функциональности. Перспектива такого действия, как, например, смена используемой библиотеки виджетов, приводит этакого программиста в ужас, внешне выражающийся фразой "что вы, это совершенно невозможно, программу для этого придётся переписать с нуля"; о том, что вид пользовательского интерфейса вообще-то можно сделать сменным, он даже подумать побоится. Такие люди часто применяют совершенно феерическую технику, которую более грамотные программисты в шутку называют "рисованием на обратной стороне экрана" — когда не хватает обработчиков событий, в диалоговом окне создаётся невидимый (sic!) графический объект, через который другие объекты обмениваются информацией.

В нынешних условиях такой программист окажется вполне востребован, больше того, ему даже будут платить неплохую зарплату; однако он никогда так и не поймёт, что он в действительности потерял и насколько более интересной могла бы быть его работа, если бы в своё время он не схватился раньше времени за пресловутые окошечки.

----

Впрочем, несмотря на всё вышесказанное, я не буду утверждать, что научить программировать, используя для этого Windows, невозможно; наверное, возможно и такое, просто лично я за это не возьмусь.

### Ссылки

* [Оригинал статьи](http://www.stolyarov.info/lessons/why_unix.html)
